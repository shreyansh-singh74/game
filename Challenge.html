<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Finger Circuit</title>
    <!-- Add permission for web-share API -->
    <meta name="permissions-policy" content="web-share=self">
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      @font-face {
            font-family: 'MyCustomFont';
            src: url('./assets/display-regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
      }

      @font-face {
            font-family: 'JapaneseFont';
            src: url('./assets/japanese.otf') format('truetype');
            font-weight: normal;
            font-style: normal;
      }

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: 'MyCustomFont', sans-serif;
        height: 100vh;
        width: 100vw;
      }

      /* Custom scrollbar styles */
      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
      }

      ::-webkit-scrollbar-thumb {
        background: #ff6699;
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #ff4d88;
      }

      .game-container {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
      }

      .title-banner {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: white;
        padding: 10px 0;
        border-radius: 0 0 20px 20px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        z-index: 100; /* Increased from 10 to appear above share modal */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 65px;
      }

      .title-banner h1 {
        color: black;
        font-size: 1.6rem;
        margin: 0;
        letter-spacing: 1px;
        font-weight: normal;
      }

      .title-banner h2 {
        color: black;
        font-size: 12px;
        margin: 5px 0 0;
        font-weight: bold;
        margin-bottom: 5px;
      }

    

      .map-container {
        flex: 1;
        position: relative;
        display: block;
        overflow: hidden;
        margin-bottom: 60px;
      }

      #gameCanvas {
        position: absolute;
        top: 0;
        width: 100%;
        height: 70%;
        margin: auto;
        left: 0;
        margin-top: 100px;
        right: 0;
        z-index: 1;
        display: block;
        max-width: 800px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        touch-action: none;
        background-image: url("assets/challenge.svg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        aspect-ratio: 350/500;
      }

      .mission-banner {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        margin-top: 0; /* Remove the top margin that was pushing it down */
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px 20px;
        text-align: center;
        z-index: 4;
        opacity: 1;
        transition: opacity 0.5s ease;
        border-radius: 0;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .mission-banner h2 {
        color: black;
        font-size: 18px;
        margin: 0;
        font-weight: bold;
        text-align: center; /* Add explicit center alignment */
      }

      .mission-banner p {
        color: black;
        font-size: 14px;
        margin: 8px 0 0;
        text-align: center; /* Add explicit center alignment */
      }

      .start-point {
        position: absolute;
        width: 100px;
        height: 40px;
        background-color: rgba(255, 102, 153, 0.7);
        border-radius: 20px;
        font-family: 'JapaneseFont', sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        z-index: 3;
        opacity: 1;
        transition: opacity 0.5s ease;
        backdrop-filter: blur(1px);
      }

      .start-arrow {
        position: absolute;
        width: 30px;
        height: 40px;
        z-index: 3;
        opacity: 1;
        transition: opacity 0.5s ease;
      }

      .white-belt {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      .result-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 20; /* Increased z-index to be above everything */
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 0 15px; /* Added padding to prevent content from touching edges */
        overflow-y: auto; /* Enable vertical scrolling */
        padding-top: 70px; /* Add padding to prevent overlap with header */
      }

      .result-modal {
        position: relative;
        width: 100%;
        max-width: 320px; /* Limit width for better mobile display */
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px; /* Add margin to push content down from header */
        margin-bottom: 20px; /* Add margin at bottom for scrolling space */
        overflow-y: auto; /* Enable scrolling within the modal */
        max-height: calc(100vh - 100px); /* Limit height to ensure it fits in viewport */
      }

      .result-modal::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="M30,20 L70,20 L80,30 L80,70 L70,80 L30,80 L20,70 L20,30 Z" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/></svg>');
        background-size: 100px 100px;
        opacity: 0.2;
        z-index: -1;
      }

      .result-title-jp {
        color: white;
        font-size: 14px;
        margin-top: 0;
        margin-bottom: 5px;
        font-family: 'JapaneseFont', sans-serif;
      }

      .result-title-en {
        color: white;
        font-size: 28px;
        font-weight: bold;
        margin-bottom: 15px;
        letter-spacing: 1px;
      }

      .completion-label {
        color: white;
        font-size: 22px;
        margin-bottom: 5px;
        text-align: center;
        font-family: 'JapaneseFont', sans-serif;
      }

      .completion-value {
        font-size: 140px; /* Reduced from 160px */
        color: #ff6699;
        text-shadow: 0 0 2px #ff6699, 0 0 8px #ff6699;
        margin: 0;
        line-height: 1;
        display: flex;
        text-align: center;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
      }

      .completion-value .percent {
        font-size: 30px;
        margin-top: 80px; /* Adjusted from 95px */
        margin-left: 5px; /* Reduced from 15px */
        color: #ff6699;
        text-shadow: 0 0 1px #ff6699;
      }

      .result-button {
        width: 100%;
        padding: 12px;
        border-radius: 30px;
        border: none;
        margin-bottom: 10px;
        font-size: 14px;
        cursor: pointer;
        text-align: center;
        font-weight: bold;
      }

      .share-button {
        background-color: #666;
        color: white;
        width: 70%;
        height: 53px;
        margin-bottom: 15px; /* Reduced from 25px */
      }

      .retry-button {
        background-color: #666;
        color: white;
        width: 70%;
        height: 53px;
        margin-bottom: 15px; /* Reduced from 30px */
      }

      .map-button {
        background-color: white;
        color: #333;
        height: 45px;
        width: 90%;
        margin-bottom: 10px; /* Added margin-bottom */
      } 
      
      button {
        font-family: 'MyCustomFont', sans-serif;
      }

      .touch-indicator {
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: transparent;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .start-tooltip {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        font-size: 14px;
        max-width: 200px;
        text-align: center;
        z-index: 5;
        animation: pulse 2s infinite;
      }

      /* Add continuation circle styles */
      .continuation-circle {
        position: fixed;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 2px solid rgba(0, 80, 255, 0.8);
        background-color: rgba(0, 80, 255, 0.1);
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 1000;
        display: none;
        animation: blink 1.5s infinite;
      }

      @keyframes blink {
        0% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.3; transform: scale(0.92); }
        100% { opacity: 1; transform: scale(1); }
      }

      .share-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 30;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow-y: auto; /* Enable vertical scrolling */
        padding-top: 70px; /* Add padding to prevent overlap with header */
      }

      .share-content {
        width: 90%;
        max-width: 350px;
        background-color: white;
        border-radius: 30px;
        padding: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        margin-top: 20px; /* Add margin to push content down from header */
        margin-bottom: 20px; /* Add margin at bottom for scrolling space */
      }

      .share-title {
        font-size: 20px;
        margin-bottom: 20px;
        text-align: center;
      }

      .share-image {
        width: 100%;
        max-width: 300px;
        margin-bottom: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid #eee;
      }

      .close-share {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #333;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 30px;
        height: 30px;
        border-radius: 50%;
      }

      .close-share:hover {
        background-color: rgba(0, 0, 0, 0.1);
      }
      
      .universal-share-button {
        width: 60px;
        height: 60px;
        background-color: #2196F3;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
        transition: background-color 0.3s, transform 0.1s;
      }
      
      .universal-share-button:hover {
        background-color: #0d8aee;
      }
      
      .universal-share-button:active {
        transform: scale(0.95);
      }

      .share-icon {
        width: 24px;
        height: 24px;
      }

      .share-loading {
        color: #666;
        font-size: 14px;
        margin: 20px 0;
      }

      /* Hidden score element for sharing */
      #scoreElement {
        width: 320px;
        height: 320px;
        background-image: url("assets/SNS-bg.png");
        background-size: cover;
        background-position: center;
        position: absolute;
        left: -9999px;
        top: -9999px;
        opacity: 0;
        z-index: -1;
        display: flex;
        flex-direction: column;
        padding: 20px;
        pointer-events: none;
        user-select: none;
        touch-action: none;
      }

      .share-header {
        margin-top: 60px;
        text-align: center;
      }

      .share-game-title {
        font-size: 28px;
        color: #000;
        margin-bottom: 10px;
      }
      .share-game-mode {
        text-align: left;
        display: inline-block;
        background-color: white;
        color: #000;
        font-size: 14px;
        padding: 4px 12px 4px 8px;
        border-radius: 30px;
        margin-bottom: 20px;
        margin-left: 8px;
        float: left;
      }

      .share-score-label {
        font-size: 18px;
        text-align: left;
        color: #fd6aa0;
        margin-bottom: 5px;
        margin-left: 50px;
        font-family: 'JapaneseFont', sans-serif;
      }

      .share-score-value {
        font-size: 90px;
        margin-left: 8px;
        color: #fd6aa0;
        line-height: 1;
        margin-bottom: 10px;
      }

      .share-circuit {
        position: absolute;
        right: 20px;
        top: 140px;
        width: 120px;
        height: 160px;
        opacity: 0.7;
      }

      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
      }

      /* Enhanced responsive styles for small screens */
      @media screen and (max-height: 600px) {
        .title-banner {
          height: 60px;
          padding: 8px 0;
        }

        .title-banner h1 {
          font-size: 1.4rem;
        }

        .title-banner h2 {
          font-size: 11px;
          margin-top: 2px;
        }

        #gameCanvas {
          height: 65%;
          margin-top: 70px;
        }
        
        .completion-value {
          font-size: 100px;
        }
        
        .completion-value .percent {
          font-size: 24px;
          margin-top: 60px;
        }
        
        .result-title-en {
          font-size: 24px;
        }
        
        .result-button {
          padding: 10px;
          margin-bottom: 8px;
        }
        
        /* Ensure result screen has proper padding on small screens */
        .result-screen {
          padding-top: 65px;
        }
      }

      @media screen and (max-height: 500px) {
        .title-banner {
          height: 50px;
          padding: 5px 0;
        }

        .title-banner h1 {
          font-size: 14px;
        }

        .title-banner h2 {
          display: none;
        }

        #gameCanvas {
          height: 60%;
          margin-top: 60px;
        }
        
        .completion-value {
          font-size: 80px;
          margin-bottom: 10px;
        }
        
        .completion-value .percent {
          font-size: 18px;
          margin-top: 45px;
        }
        
        .result-button {
          padding: 8px;
          margin-bottom: 6px;
        }
        
        .share-button, .retry-button {
          height: 40px;
          margin-bottom: 10px;
        }
        
        .map-button {
          height: 35px;
        }
        
        .result-title-jp {
          font-size: 12px;
        }
        
        .result-title-en {
          font-size: 20px;
          margin-bottom: 10px;
        }
        
        .completion-label {
          font-size: 18px;
          margin-bottom: 3px;
        }
        
        /* Ensure result screen has proper padding on very small screens */
        .result-screen {
          padding-top: 55px;
        }
      }

      @media screen and (max-width: 360px) {
        .title-banner h1 {
          font-size: 14px;
        }
        
        .title-banner h2 {
          font-size: 10px;
        }
        
        .start-point {
          width: 80px;
          font-size: 12px;
        }
        
        .share-content {
          width: 95%;
          padding: 20px 15px;
        }
        
        .share-title {
          font-size: 18px;
        }
        
        .result-button {
          width: 85%;
        }
        
        .completion-value {
          font-size: 90px;
        }
        
        .completion-value .percent {
          font-size: 20px;
          margin-top: 50px;
          margin-left: 3px;
        }
        
        /* Ensure buttons are visible on small screens */
        .result-modal {
          padding-bottom: 20px;
        }
      }

      @media screen and (min-width: 768px) {
        #gameCanvas {
          max-width: 700px;
          height: 75%;
        }
      }
      
      /* Landscape orientation adjustments */
      @media screen and (max-height: 450px) and (orientation: landscape) {
        .title-banner {
          height: 40px;
          padding: 5px 0;
        }
        
        .title-banner h2 {
          display: none;
        }
        
        #gameCanvas {
          height: 80%;
          margin-top: 50px;
          max-width: 350px;
        }
        
        .result-screen {
          padding-top: 45px;
        }
        
        .completion-value {
          font-size: 70px;
          margin-bottom: 5px;
        }
        
        .completion-value .percent {
          font-size: 16px;
          margin-top: 40px;
        }
        
        .result-button {
          padding: 6px;
          margin-bottom: 5px;
          font-size: 12px;
        }
        
        .share-button, .retry-button {
          height: 35px;
          margin-bottom: 8px;
        }
        
        .map-button {
          height: 30px;
        }
      }
      
      /* Specific styles for iPhone SE and mini */
      @media screen and (max-width: 375px) and (max-height: 667px) {
        .result-screen {
          padding-top: 65px;
          padding-bottom: 20px;
        }
        
        .result-modal {
          margin-top: 10px;
          margin-bottom: 30px;
        }
        
        /* Ensure buttons are visible with scrolling */
        .map-button {
          margin-bottom: 30px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <canvas id="gameCanvas"></canvas>

      <div class="title-banner">
        <h1>
          FIN<span style="color: #E00400;">G</span>ER CIRC<span style="color: #E00400;">U</span>IT
        </h1>
        <h2 class="HiraginoBold" style="font-size: 12px; font-weight: 900; ">フィンガーサーキット</h2>
      </div>

      <div class="mission-banner">
        <h2>MISSION</h2>
        <p style="font-family: 'JapaneseFont';">青い補助線に沿ってサーキットを描いてみよう！</p>
      </div>

      <div id="startPoint" class="start-point">スタート</div>
      <div id="startArrow" class="start-arrow">
        <svg width="30" height="40" viewBox="0 0 30 40">
          <path d="M15 5 L15 35" stroke="#ff6699" stroke-width="3" />
          <path d="M15 5 L10 10" stroke="#ff6699" stroke-width="3" />
          <path d="M15 5 L20 10" stroke="#ff6699" stroke-width="3" />
        </svg>
      </div>

      <div id="whiteBelt" class="white-belt"></div>

      <div id="touchIndicator" class="touch-indicator"></div>
      
      <!-- Add continuation circle element -->
      <div id="continuationCircle" class="continuation-circle"></div>

      <div id="resultScreen" class="result-screen">
        <div class="result-modal">
          <div class="result-title-jp" style="font-family: 'JapaneseFont', sans-serif;">ミッションクリア</div>
          <div class="result-title-en">MISSION CLEAR</div>
          <div class="completion-label" style="font-family: 'JapaneseFont', sans-serif;">完成度</div>
          <div class="completion-value">
            <span id="accuracyResult"></span>
            <span class="percent">%</span>
          </div>
          <button id="shareButton" class="result-button share-button" style="font-family: 'JapaneseFont', sans-serif;">
            SNSでシェアする
          </button>
          <button id="retryButton" class="result-button retry-button" style="font-family: 'JapaneseFont', sans-serif;">
            もう一度遊ぶ
          </button>
          <a href="https://miniapp.line.me/2007078799-0oWyrXee/circuitjourney" style="text-decoration: none; width: 90%;">
            <button id="mapButton" class="result-button map-button">
              CI<span style="color:#E00400">R</span>CUIT JOURN<span style="color:#E00400">E</span>Y
            </button>
          </a>
        </div>
      </div>

      <!-- Hidden element for generating share image -->
      <div id="scoreElement">
        <div class="share-header">
          <div class="share-game-title">FINGER CIRCUIT</div>
          <div class="share-game-mode">CHALLENGE</div>
        </div>
        <div class="share-score-label" style="font-family: 'JapaneseFont', sans-serif;">完成度</div>
        <div class="share-score-value">
          <span id="shareAccuracyValue"></span>
          <span style="font-size: 30px;">%</span>
        </div>
        <canvas id="circuitCanvas" class="share-circuit"></canvas>
      </div>

      <!-- Social Share Modal -->
      <div id="shareModal" class="share-modal">
        <div class="share-content">
          <button id="closeShare" class="close-share">×</button>
          <div class="share-title">Share Your Score !!!</div>
          <img id="shareImage" class="share-image" alt="Your score" />
          <button id="universalShareButton" class="universal-share-button">
            <svg class="share-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
              <path d="M0 0h24v24H0z" fill="none"/>
              <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Get canvas and context
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const touchIndicator = document.getElementById("touchIndicator");
        const continuationCircle = document.getElementById("continuationCircle");

        // Game state and variables
        const gameState = {
          status: "initializing", // initializing, ready, playing, completed
          difficulty: "challenge",
          userPath: [],
          lastPoint: null,
          isDrawing: false,
          startPoint: { x: 0, y: 0 }, // Will be set properly in initializeCircuitPath
          startRadius: 8, // Reduced for better precision
          circuitPath: [],
          completionThreshold: 20, // Distance to consider the circuit completed when returning to start
          accuracy: 0,
          minDrawDistance: 1, // Reduced for better sensitivity
          interpolationPoints: 5, // Increased for smoother curves
          pathWidth: 20, // Width of the circuit path for accuracy calculation - increased for better detection
          redrawScheduled: false,
          touchActive: false, // Track if touch is active for better responsiveness
          lastTouchTime: 0, // Track last touch time for better responsiveness
          
          // Path progression tracking for better accuracy calculation
          pathProgression: 0,          // Current progress along the circuit path (0-100%)
          lastSegmentIndex: 0,         // Last closest segment for path progression
          accuracyPoints: 0,           // Points earned for accuracy
          totalPossiblePoints: 0,      // Total possible accuracy points
          segmentsVisited: new Set(),  // Track which segments the user has visited
          visitedInOrder: [],          // Track segments visited in order
          minCircuitCoverage: 0.3,     // Minimum percentage of circuit that must be covered - reduced to allow partial completion
          fullLoopRequired: false,     // Don't require a full loop for accuracy calculation
          lastCheckpointIndex: -1,     // Last checkpoint segment index reached
          
          // Flag to prevent drawing after completion
          circuitCompleted: false,
          
          // Flag to track if we're in the process of calculating accuracy
          calculatingAccuracy: false,
          
          // Flag to control straight line behavior when lifting finger
          preventStraightLines: true, // Changed to prevent connecting lines when lifting finger
          
          // Flag to allow completion without full circuit
          allowPartialCompletion: true, // Allow showing results even with partial completion
          
          // Minimum time (ms) before allowing completion check
          minPlayTime: 3000,
          gameStartTime: 0,
          
          // Track if we're currently in a continuous drawing or starting a new segment
          isNewSegment: false,
          
          // Track segments that have been touched at least once
          touchedSegments: new Set(),
          
          // Track all segments (visible and invisible) for accuracy
          allSegmentsTouched: new Set(),
          
          // Track if we should check for completion on finger lift
          checkCompletionOnLift: true,
          
          // Quick completion when near end point
          quickCompletionEnabled: true,
          
          // Add additional flags to control completion checking
          justResumedDrawing: false,
          minDistanceAfterResume: 30,
          distanceSinceResume: 0,
          resumePoint: null,
          
          // Prevent accidental quick completions
          quickCompletionThreshold: 15,
          
          // Continuation circle radius (approx 1cm)
          continuationRadius: 20, // 20px radius = 40px diameter, ~1cm
          
          // Store the last point where the finger was lifted
          lastLiftPoint: null,
          
          // Pre-rendered share image
          cachedShareImage: null
        };

        // Set canvas size
        function resizeCanvas() {
          // Get the container dimensions
          const container = canvas.parentElement;

          // Calculate the available width and height
          const availableWidth = Math.min(window.innerWidth, 800); // Cap at max-width

          // Maintain the aspect ratio of 350:500 (from the original design)
          const aspectRatio = 350 / 500;

          // Set canvas dimensions based on available width and maintaining aspect ratio
          canvas.width = availableWidth;
          canvas.height = availableWidth / aspectRatio;

          // Make sure the canvas height doesn't exceed the available height
          const maxHeight = window.innerHeight * 0.7;
          if (canvas.height > maxHeight) {
            canvas.height = maxHeight;
            canvas.width = maxHeight * aspectRatio;
          }

          // Re-initialize circuit path after resize
          initializeCircuitPath();

          // Re-draw everything after resize
          if (gameState.status === "playing" || gameState.status === "ready") {
            drawCircuit();
            if (gameState.userPath.length > 0) {
              drawUserPath();
            }
          }
        }

        window.addEventListener("resize", resizeCanvas);

        // Create circuit path
        function initializeCircuitPath() {
          // Define the base coordinates for a 350x500 canvas
          // These are the fixed coordinates that will be scaled to any screen size
          // Updated visibility to match the image: 
          // 2 = fully visible (dark blue)
          // 1 = partially visible (light blue) 
          // 0 = hidden but still part of the circuit
            const baseCoordinates = [
            // Start point
            { x: 82, y: 170, visible: 0 },

            // Vertical line up
            { x: 75, y: 80, visible: 0 },
            { x: 75, y: 50, visible: 0 },

            // Top loop
            { x: 100, y: 38, visible: 0 },
            { x: 115, y: 60, visible: 0 },
            { x: 110, y: 95, visible: 0 },
            { x: 100, y: 110, visible: 0 },
            { x: 125, y: 120, visible: 0 },
            { x: 100, y: 150, visible: 0 },
            { x: 115, y: 155, visible: 0 },

            // S-curve section
            { x: 130, y: 180, visible: 0 },
            { x: 80, y: 200, visible: 0 },
            { x: 90, y: 220, visible: 0 },
            { x: 105, y: 240, visible: 0 },
            { x: 140, y: 220, visible: 0 },
            { x: 150, y: 250, visible: 0 },
            { x: 205, y: 250, visible: 0 },
            { x: 180, y: 300, visible: 0 },
            { x: 130, y: 340, visible: 0 },

            // Horizontal middle section
            { x: 200, y: 320, visible: 0 },

            // Right curve down 
            { x: 265, y: 390, visible: 0 },
            { x: 220, y: 430, visible: 0 },

            // Bottom large loop
            { x: 270, y: 470, visible: 0 },
            { x: 290, y: 420, visible: 0 },
            { x: 240, y: 300, visible: 0 },

            // Return path
            { x: 200, y: 300, visible: 0 },
            { x: 65, y: 230, visible: 0 },
            { x: 73, y: 150, visible: 0 },
            ];

          // Calculate the scale factors based on current canvas size
          const scaleX = canvas.width / 350;
          const scaleY = canvas.height / 500;

          // Set the start point
          gameState.startPoint = {
            x: baseCoordinates[0].x * scaleX,
            y: baseCoordinates[0].y * scaleY,
          };

          // Scale all the coordinates to the current canvas size
          gameState.circuitPath = baseCoordinates.map((point) => ({
            x: point.x * scaleX,
            y: point.y * scaleY,
            visible: point.visible // Preserve visibility property
          }));

          // Position the start UI elements
          positionStartElements();

          // Force redraw
          drawCircuit();
        }

        // Position the start point and arrow UI elements
        function positionStartElements() {
          const startPointElem = document.getElementById("startPoint");
          const startArrowElem = document.getElementById("startArrow");

          startPointElem.style.left = `${gameState.startPoint.x - 50}px`;
          startPointElem.style.top = `${gameState.startPoint.y + 150}px`;

          startArrowElem.style.left = `${gameState.startPoint.x - 25}px`;
          startArrowElem.style.top = `${gameState.startPoint.y + 60}px`;
        }

        // Show start tooltip
        function showStartTooltip() {
          const tooltip = document.createElement("div");
          tooltip.className = "start-tooltip";
          tooltip.style.left = `${gameState.startPoint.x - 100}px`;
          tooltip.style.top = `${gameState.startPoint.y + 100}px`;
          document.body.appendChild(tooltip);
          
          // Remove tooltip after 5 seconds or when game starts
          setTimeout(() => {
            if (document.body.contains(tooltip)) {
              document.body.removeChild(tooltip);
            }
          }, 5000);
          
          // Store reference to remove it when game starts
          gameState.startTooltip = tooltip;
        }

        // Draw the circuit guidelines - modified to show only visible parts of the circuit
        function drawCircuit() {
          // Clear the entire canvas to keep the map visible
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw fully visible segments (dark blue)
          drawCircuitSegments(2, "rgba(0, 0, 180, 0.9)", 6);
          
          // Draw partially visible segments (light blue)
          drawCircuitSegments(1, "rgba(0, 0, 180, 0.9)", 6);

          // Draw the start point (pink circle)
          ctx.beginPath();
          ctx.arc(
            gameState.startPoint.x,
            gameState.startPoint.y,
            gameState.startRadius,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = "#ff6699";
          ctx.fill();

          // Add a pulsing effect to the start point
          if (gameState.status === "ready") {
            // Draw outer circle with animation - smaller pulse size
            const pulseSize =
              gameState.startRadius * 1.5 + Math.sin(Date.now() / 200) * 3;
            ctx.beginPath();
            ctx.arc(
              gameState.startPoint.x,
              gameState.startPoint.y,
              pulseSize,
              0,
              Math.PI * 2
            );
            ctx.strokeStyle = "#ff6699";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Request animation frame to keep pulsing
            if (gameState.status === "ready") {
              requestAnimationFrame(drawCircuit);
            }
          }
        }

        // Draw circuit segments with specified visibility level
        function drawCircuitSegments(visibilityLevel, strokeStyle, lineWidth) {
          // Find segments with the specified visibility level
          let segments = [];
          let currentSegment = [];
          
          for (let i = 0; i < gameState.circuitPath.length; i++) {
            const point = gameState.circuitPath[i];
            
            if (point.visible === visibilityLevel) {
              currentSegment.push(point);
            } else if (currentSegment.length > 0) {
              // End of a segment, save it if it has at least 2 points
              if (currentSegment.length >= 2) {
                segments.push([...currentSegment]);
              }
              currentSegment = [];
            }
          }
          
          // Don't forget the last segment
          if (currentSegment.length >= 2) {
            segments.push(currentSegment);
          }
          
          // Draw each segment with smooth curves
          segments.forEach(segment => {
            if (segment.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(segment[0].x, segment[0].y);
            
            // Draw curves between points
            for (let i = 1; i < segment.length - 1; i++) {
              const current = segment[i];
              const next = segment[i + 1];
              
              // Calculate midpoint for quadratic curve
              const xc = (current.x + next.x) / 2;
              const yc = (current.y + next.y) / 2;
              
              // Draw a quadratic curve
              ctx.quadraticCurveTo(current.x, current.y, xc, yc);
            }
            
            // Connect to the last point
            if (segment.length > 1) {
              ctx.lineTo(segment[segment.length - 1].x, segment[segment.length - 1].y);
            }
            
            // Set appearance
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
          });
        }

        // Draw the user's path
        function drawUserPath() {
          if (gameState.userPath.length < 2) return;

          // Draw each segment of the user path separately (no connections between lifted segments)
          let segments = [];
          let currentSegment = [];
          
          // First point is always the start of a segment
          currentSegment.push(gameState.userPath[0]);
          
          // Identify segments based on large distances (lifted finger)
          for (let i = 1; i < gameState.userPath.length; i++) {
            const prev = gameState.userPath[i-1];
            const curr = gameState.userPath[i];
            const distance = distanceBetween(prev, curr);
            
            // If distance is too large, it means the finger was lifted
            if (distance > 30) { // Threshold to detect lifted finger
              if (currentSegment.length > 0) {
                segments.push([...currentSegment]);
                currentSegment = [];
              }
            }
            
            currentSegment.push(curr);
          }
          
          // Add the last segment
          if (currentSegment.length > 0) {
            segments.push(currentSegment);
          }
          
          // Draw each segment with smooth curves
          for (const segment of segments) {
            if (segment.length < 2) continue;
            
            ctx.beginPath();
            ctx.moveTo(segment[0].x, segment[0].y);
            
            for (let i = 1; i < segment.length - 1; i++) {
              const current = segment[i];
              const next = segment[i + 1];
              const xc = (current.x + next.x) / 2;
              const yc = (current.y + next.y) / 2;
              ctx.quadraticCurveTo(current.x, current.y, xc, yc);
            }
            
            // Connect to the last point in the segment
            const last = segment[segment.length - 1];
            ctx.lineTo(last.x, last.y);
            
            // More visible user path
            ctx.strokeStyle = "rgba(0, 0, 180, 0.9)"; // blue
            ctx.lineWidth = 3;
            ctx.lineCap = "round"; // Add rounded ends to the line
            ctx.lineJoin = "round"; // Add rounded corners
            ctx.stroke();
          }

          // After drawing the user path, redraw the circuit guidelines
          drawCircuitOverlay();
        }

        // Draw just the circuit overlay without clearing
        function drawCircuitOverlay() {
          // Draw fully visible segments with lighter transparency
          drawCircuitSegments(2, "rgba(0, 0, 180, 0.5)", 7);
          
          // Draw partially visible segments with lighter transparency
          drawCircuitSegments(1, "rgba(100, 100, 255, 0.4)", 6);
        }

        // Interpolate between two points to add more points for smoother drawing
        function interpolatePoints(p1, p2, numPoints) {
          const points = [];
          
          for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            points.push({
              x: p1.x + (p2.x - p1.x) * t,
              y: p1.y + (p2.y - p1.y) * t
            });
          }
          
          return points;
        }

        // Find the closest point on the circuit path to a given point
        function findClosestPointOnPath(point) {
          let minDist = Infinity;
          let closestPoint = null;
          let closestSegmentIndex = -1;
          
          // Check against each segment of the path
          for (let i = 0; i < gameState.circuitPath.length - 1; i++) {
            const p1 = gameState.circuitPath[i];
            const p2 = gameState.circuitPath[i + 1];
            
            // Find closest point on this segment
            const closest = closestPointOnSegment(point, p1, p2);
            const dist = distanceBetween(point, closest);
            
            if (dist < minDist) {
              minDist = dist;
              closestPoint = closest;
              closestSegmentIndex = i;
            }
          }
          
          return { 
            point: closestPoint, 
            distance: minDist,
            segmentIndex: closestSegmentIndex
          };
        }

        // Find the closest point on a line segment to a given point
        function closestPointOnSegment(p, v, w) {
          // Return minimum distance between line segment vw and point p
          const l2 = distanceSquared(v, w);  // i.e. |w-v|^2
          
          // Consider the line extending the segment, parameterized as v + t (w - v)
          // We find projection of point p onto the line.
          // It falls where t = [(p-v) . (w-v)] / |w-v|^2
          // We clamp t from [0,1] to handle points outside the segment vw
          
          if (l2 === 0) return v; // v == w case
          
          // Consider the line extending the segment, parameterized as v + t (w - v)
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          
          return {
            x: v.x + t * (w.x - v.x),
            y: v.y + t * (w.y - v.y)
          };
        }

        // Calculate squared distance between two points
        function distanceSquared(v, w) {
          return Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
        }

        // Calculate distance between two points
        function distanceBetween(p1, p2) {
          return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // Check if the user has completed the circuit - enhanced version
        function checkCompletion(forceCheck = false) {
          // Don't check completion if we're already completed or calculating
          if (gameState.circuitCompleted || gameState.calculatingAccuracy) return false;
          
          // Need a minimum path length
          if (gameState.userPath.length < 5) return false;
          
          // Need minimum play time before allowing completion check
          if (!forceCheck && Date.now() - gameState.gameStartTime < 500) return false;
          
          const lastPoint = gameState.userPath[gameState.userPath.length - 1];
          
          // Check for ending at either the start point OR the end point
          const startPoint = gameState.circuitPath[0];
          const endPoint = gameState.circuitPath[gameState.circuitPath.length - 1];
          
          // Calculate distances to start and end points
          const distanceToStart = Math.hypot(lastPoint.x - startPoint.x, lastPoint.y - startPoint.y);
          const distanceToEnd = Math.hypot(lastPoint.x - endPoint.x, lastPoint.y - endPoint.y);
          
          // Set slightly more forgiving detection radius (but not too large)
          const completionRadius = 20;
          
          // Complete if touching start OR end point
          if (distanceToStart < completionRadius || distanceToEnd < completionRadius) {
            // Set circuit as completed to prevent further drawing
            gameState.circuitCompleted = true;
            gameState.calculatingAccuracy = true;
            
            // Calculate accuracy with a small delay to improve responsiveness
            setTimeout(() => {
              calculateAccuracy();
              gameState.calculatingAccuracy = false;
              showResultScreen();
            }, 100);
            
            return true;
          }

          return false;
        }

        // Calculate accuracy by comparing user path to ideal path
        function calculateAccuracy() {
          // If the user path is too short, accuracy is very low but not zero
          if (gameState.userPath.length < 5) {
            gameState.accuracy = 5; // Minimum accuracy score
            document.getElementById("accuracyResult").textContent = gameState.accuracy;
            return;
          }
          
          // WEIGHTED FACTOR SCORING SYSTEM
          // 1. Calculate circuit coverage (how much of the circuit was touched)
          const totalSegments = gameState.circuitPath.length - 1; 
          const touchedSegments = gameState.allSegmentsTouched.size;
          const rawCoverage = touchedSegments / totalSegments;
          
          // 2. Check for key checkpoint coverage (evenly spaced important points)
          const checkpointSegments = [];
          const checkpointCount = 10; // More checkpoints for better accuracy
          const segmentInterval = Math.max(1, Math.floor(totalSegments / checkpointCount));
          
          for (let i = 0; i < totalSegments; i += segmentInterval) {
            checkpointSegments.push(i);
          }
          // Ensure start and end segments are included
          if (!checkpointSegments.includes(0)) checkpointSegments.push(0);
          if (!checkpointSegments.includes(totalSegments - 1)) checkpointSegments.push(totalSegments - 1);
          
          // Count how many checkpoints were visited
          let checkpointsVisitedCount = 0;
          for (const checkpointIndex of checkpointSegments) {
            if (gameState.allSegmentsTouched.has(checkpointIndex)) {
              checkpointsVisitedCount++;
            }
          }
          
          const checkpointRatio = checkpointsVisitedCount / checkpointSegments.length;
          
          // 3. Track precision (how closely user followed the path)
          // Calculate average distance of user path points to the circuit path
          let totalDistanceToPath = 0;
          let pointsChecked = 0;
          
          // Sample user path points (not all points to save performance)
          const sampleInterval = Math.max(1, Math.floor(gameState.userPath.length / 50));
          for (let i = 0; i < gameState.userPath.length; i += sampleInterval) {
            const point = gameState.userPath[i];
            const closestInfo = findClosestPointOnPath(point);
            totalDistanceToPath += Math.min(closestInfo.distance, gameState.pathWidth * 2);
            pointsChecked++;
          }
          
          // Convert average distance to a 0-1 precision score (lower distance = better precision)
          const avgDistance = pointsChecked > 0 ? totalDistanceToPath / pointsChecked : gameState.pathWidth;
          const precisionScore = Math.max(0, 1 - (avgDistance / (gameState.pathWidth * 2)));
          
          // Final weighted accuracy calculation
          const weightCoverage = 0.5;       // 50% weight on covering the whole circuit
          const weightCheckpoints = 0.3;    // 30% weight on hitting critical checkpoints
          const weightPrecision = 0.2;      // 20% weight on drawing precision
          
          let finalScore = (rawCoverage * weightCoverage) + 
                          (checkpointRatio * weightCheckpoints) + 
                          (precisionScore * weightPrecision);
          
          // Adjust score based on coverage thresholds
          if (rawCoverage < 0.3) {
            // Severely penalize very low coverage
            finalScore *= 0.5;
          } else if (checkpointRatio < 0.4) {
            // Penalize missing too many checkpoints
            finalScore *= 0.7;
          }
          
          // Convert to percentage
          gameState.accuracy = Math.round(finalScore * 100);
          
          // Ensure accuracy is between 5 and 100
          gameState.accuracy = Math.max(5, Math.min(100, gameState.accuracy));
          
          // Update UI immediately
          document.getElementById("accuracyResult").textContent = gameState.accuracy;
        }

        // Handle touch/mouse events
        function handleStart(e) {
          e.preventDefault();
          
          // Don't allow drawing if circuit is completed
          if (gameState.circuitCompleted) return;
          
          // Get the touch position
          const pos = getEventPosition(e);
          
          // Update touch state
          gameState.touchActive = true;
          gameState.lastTouchTime = Date.now();

          // Check if we're in ready state (first touch)
          if (gameState.status === "ready") {
            // Check if starting near the start point
            const dx = pos.x - gameState.startPoint.x;
            const dy = pos.y - gameState.startPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Increased detection radius for better usability
            if (distance < gameState.startRadius * 4) {
              // Start drawing
              gameState.isDrawing = true;
              gameState.status = "playing";
              gameState.gameStartTime = Date.now();
              gameState.userPath = [
                { x: gameState.startPoint.x, y: gameState.startPoint.y },
              ];
              gameState.lastPoint = {
                x: gameState.startPoint.x,
                y: gameState.startPoint.y,
              };

              // Reset segment tracking
              gameState.touchedSegments = new Set();
              gameState.allSegmentsTouched = new Set([0]); // Mark first segment as touched
              gameState.visitedInOrder = [];
              gameState.lastCheckpointIndex = -1;

              // Fade out start elements
              document.getElementById("startPoint").style.opacity = "0";
              document.getElementById("startArrow").style.opacity = "0";
              
              // Remove start tooltip if it exists
              if (gameState.startTooltip && document.body.contains(gameState.startTooltip)) {
                document.body.removeChild(gameState.startTooltip);
              }

              // Force redraw to show initial state
              drawCircuit();
              drawUserPath();
            }
          } 
          // Check if we're already playing but not currently drawing (we lifted finger before)
          else if (gameState.status === "playing" && !gameState.isDrawing) {
            // Get canvas position
            const canvasRect = canvas.getBoundingClientRect();
            
            // Convert touch position to be relative to viewport
            const touchX = pos.x + canvasRect.left;
            const touchY = pos.y + canvasRect.top;
            
            // Check if touching within the continuation circle
            const canContinue = gameState.lastLiftPoint && 
                               Math.hypot(touchX - gameState.lastLiftPoint.x, 
                                        touchY - gameState.lastLiftPoint.y) <= gameState.continuationRadius;
            
            if (canContinue) {
              // Continue drawing from current touch point
              gameState.isDrawing = true;
              gameState.isNewSegment = true;
              
              // Hide continuation circle
              continuationCircle.style.display = "none";
              
              // Track that we've just resumed drawing
              gameState.justResumedDrawing = true;
              gameState.distanceSinceResume = 0;
              gameState.resumePoint = { x: pos.x, y: pos.y };
              
              // Start a new segment at touch point
              gameState.lastPoint = { x: pos.x, y: pos.y };
              gameState.userPath.push({ x: pos.x, y: pos.y });
              
              drawCircuit();
              drawUserPath();
            }
          }
        }

        function handleMove(e) {
          e.preventDefault();

          // Don't allow drawing if circuit is completed
          if (gameState.circuitCompleted) return;
          
          if (!gameState.isDrawing) return;

          // Get the touch position
          const pos = getEventPosition(e);
          
          // Update touch state
          gameState.touchActive = true;
          gameState.lastTouchTime = Date.now();

          // Calculate distance from last point
          let addPoint = true;
          if (gameState.lastPoint) {
            const dx = pos.x - gameState.lastPoint.x;
            const dy = pos.y - gameState.lastPoint.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Only add point if we've moved far enough (makes line smoother)
            if (dist < gameState.minDrawDistance) {
              addPoint = false;
            }
          }

          if (addPoint) {
            // If the distance between points is large, add interpolated points
            if (gameState.lastPoint) {
              const dx = pos.x - gameState.lastPoint.x;
              const dy = pos.y - gameState.lastPoint.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              // Track distance moved since resuming drawing
              if (gameState.justResumedDrawing && gameState.resumePoint) {
                const distanceFromResume = distanceBetween(pos, gameState.resumePoint);
                gameState.distanceSinceResume = distanceFromResume;
                
                // If moved enough, stop flagging as just resumed
                if (distanceFromResume > gameState.minDistanceAfterResume) {
                  gameState.justResumedDrawing = false;
                }
              }
              
              // If points are far apart, add interpolated points between them
              if (dist > 10) {
                const interpolated = interpolatePoints(
                  gameState.lastPoint,
                  pos, 
                  gameState.interpolationPoints
                );
                
                // Skip the first point as it's the same as lastPoint
                for (let i = 1; i < interpolated.length; i++) {
                  gameState.userPath.push(interpolated[i]);
                  
                  // Check if this point is on a circuit segment and track it
                  const closestInfo = findClosestPointOnPath(interpolated[i]);
                  if (closestInfo.distance <= gameState.pathWidth) {
                    gameState.touchedSegments.add(closestInfo.segmentIndex);
                    gameState.allSegmentsTouched.add(closestInfo.segmentIndex);
                    
                    // Check if we're at the last segment to detect completion
                    const lastSegment = gameState.circuitPath.length - 2;
                    if (closestInfo.segmentIndex === lastSegment) {
                      // We're very near the end, check for actual completion
                      const endPoint = gameState.circuitPath[gameState.circuitPath.length - 1];
                      const distToEnd = distanceBetween(interpolated[i], endPoint);
                      if (distToEnd <= gameState.completionThreshold) {
                        // We've reached the end point - check completion
                        checkCompletion(true);
                      }
                    }
                  }
                }
              } else {
                // Just add the current point
                gameState.userPath.push({ x: pos.x, y: pos.y });
                
                // Check if this point is on a circuit segment and track it
                const closestInfo = findClosestPointOnPath(pos);
                if (closestInfo.distance <= gameState.pathWidth) {
                  gameState.touchedSegments.add(closestInfo.segmentIndex);
                  gameState.allSegmentsTouched.add(closestInfo.segmentIndex);
                  
                  // Check if we're at the last segment to detect completion
                  const lastSegment = gameState.circuitPath.length - 2; 
                  if (closestInfo.segmentIndex === lastSegment) {
                    // We're very near the end, check for actual completion
                    const endPoint = gameState.circuitPath[gameState.circuitPath.length - 1];
                    const distToEnd = distanceBetween(pos, endPoint);
                    if (distToEnd <= gameState.completionThreshold) {
                      // We've reached the end point - check completion
                      checkCompletion(true);
                    }
                  }
                }
              }
            } else {
              gameState.userPath.push({ x: pos.x, y: pos.y });
            }
            
            gameState.lastPoint = { x: pos.x, y: pos.y };
            gameState.isNewSegment = false;

            // Use requestAnimationFrame for smoother drawing
            if (!gameState.redrawScheduled) {
              gameState.redrawScheduled = true;
              requestAnimationFrame(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawCircuit();
                drawUserPath();
                gameState.redrawScheduled = false;
              });
            }

            // Only check for completion if we're not just resuming drawing
            if (!gameState.justResumedDrawing) {
              checkCompletion();
            }
          }
        }

        function handleEnd(e) {
          e.preventDefault();

          if (gameState.isDrawing) {
            gameState.isDrawing = false;
            gameState.touchActive = false;
            
            // Check completion when finger is lifted - possibly user ended near end point
            if (gameState.userPath.length > 5) {
              const lastPoint = gameState.userPath[gameState.userPath.length - 1];
              const endPoint = gameState.circuitPath[gameState.circuitPath.length - 1];
              const distToEnd = distanceBetween(lastPoint, endPoint);
              
              // More generous threshold when lifting finger
              if (distToEnd <= gameState.completionThreshold * 1.5) {
                checkCompletion(true);
              }
            }
            
            // Store the last point where finger was lifted
            if (gameState.lastPoint && !gameState.circuitCompleted) {
              // Get canvas position
              const canvasRect = canvas.getBoundingClientRect();
              
              // Calculate position relative to viewport, centered on the line endpoint
              const x = gameState.lastPoint.x + canvasRect.left;
              const y = gameState.lastPoint.y + canvasRect.top;
              
              // Store the last lift point
              gameState.lastLiftPoint = { x, y };
              
              // Show continuation circle at the exact lift point
              continuationCircle.style.display = "block";
              continuationCircle.style.position = "fixed";
              // Center the circle by offsetting by its radius (20px)
              continuationCircle.style.left = (x - 20) + "px";
              continuationCircle.style.top = (y - 20) + "px";
            }
            
            gameState.justResumedDrawing = false;
          }
        }

        function getEventPosition(e) {
          let x, y;
          const rect = canvas.getBoundingClientRect();

          try {
            if (e.type.includes("touch")) {
              const touch = e.touches[0] || e.changedTouches[0];
              if (!touch) {
                console.error("No touch found in event:", e);
                return { x: 0, y: 0 };
              }
              x = touch.clientX - rect.left;
              y = touch.clientY - rect.top;
            } else {
              x = e.clientX - rect.left;
              y = e.clientY - rect.top;
            }

            // Scale coordinates if canvas is scaled
            x *= canvas.width / rect.width;
            y *= canvas.height / rect.height;

            return { x, y };
          } catch (error) {
            console.error("Error in getEventPosition:", error);
            return { x: 0, y: 0 };
          }
        }

        function showResultScreen() {
          document.getElementById("accuracyResult").textContent = gameState.accuracy;
          document.getElementById("resultScreen").style.display = "flex";
          
          // Make sure the share accuracy value is also updated
          document.getElementById("shareAccuracyValue").textContent = gameState.accuracy;
          
          // Ensure the result screen is scrollable
          document.getElementById("resultScreen").style.overflowY = "auto";
          
          // Ensure the modal doesn't overlap with the header
          const titleBannerHeight = document.querySelector(".title-banner").offsetHeight;
          document.getElementById("resultScreen").style.paddingTop = (titleBannerHeight + 5) + "px";
        }

        // Prepare the share element with current game data
        function prepareShareElement() {
          // Only render the score element when needed
          document.getElementById("shareAccuracyValue").textContent = gameState.accuracy;
          
          // Draw the circuit on the share canvas
          const circuitCanvas = document.getElementById("circuitCanvas");
          const circuitCtx = circuitCanvas.getContext("2d");
          
          // Set canvas size
          circuitCanvas.width = 120;
          circuitCanvas.height = 160;
          
          // Clear canvas
          circuitCtx.clearRect(0, 0, circuitCanvas.width, circuitCanvas.height);
          
          // Scale factor to fit the circuit in the small canvas
          const scaleX = circuitCanvas.width / canvas.width;
          const scaleY = circuitCanvas.height / canvas.height;
          
          // Draw the circuit path (light gray)
          circuitCtx.beginPath();
          
          // Draw the circuit guidelines
          for (let i = 0; i < gameState.circuitPath.length - 1; i++) {
           
          }
          
          circuitCtx.strokeStyle = "rgba(100, 100, 100, 0.5)";
          circuitCtx.lineWidth = 1;
          circuitCtx.stroke();
          
          // Draw the user path (blue)
          if (gameState.userPath.length > 1) {
            // Draw each segment of the user path separately
            let segments = [];
            let currentSegment = [];
            
            // First point is always the start of a segment
            currentSegment.push(gameState.userPath[0]);
            
            // Identify segments based on large distances (lifted finger)
            for (let i = 1; i < gameState.userPath.length; i++) {
              const prev = gameState.userPath[i-1];
              const curr = gameState.userPath[i];
              const distance = distanceBetween(prev, curr);
              
              // If distance is too large, it means the finger was lifted
              if (distance > 30) {
                if (currentSegment.length > 0) {
                  segments.push([...currentSegment]);
                  currentSegment = [];
                }
              }
              
              currentSegment.push(curr);
            }
            
            // Add the last segment
            if (currentSegment.length > 0) {
              segments.push(currentSegment);
            }
            
            // Draw each segment
            for (const segment of segments) {
              if (segment.length < 2) continue;
              
              circuitCtx.beginPath();
              circuitCtx.moveTo(segment[0].x * scaleX, segment[0].y * scaleY);
              
              for (let i = 1; i < segment.length; i++) {
                circuitCtx.lineTo(segment[i].x * scaleX, segment[i].y * scaleY);
              }
              
              circuitCtx.strokeStyle = "rgba(0, 0, 180, 0.9)";
              circuitCtx.lineWidth = 2;
              circuitCtx.stroke();
            }
          }
          
          // Use a small timeout to let the component render first
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, 100);
          });
        }

        // Universal sharing function that works across all platforms
        async function shareScore() {
          try {
            // Create shareText with game info, score, and links
            const shareText = `#フィンガーサーキット で鈴鹿サーキットの一筆書きに挑戦！🏁
結果はこちら！みんなの記録は？🔥
"F1 Japanese GP" LINE公式アカウントを友だち追加して、今すぐチャレンジ！👇
https://liff.line.me/2006572406-D3OkWx32?tcode=YAQaP0000013430
#F1jp #F1日本グランプリ`;

            const shortTitle = `FINGER CIRCUIT`;
            
            // Always try to copy text to clipboard as a fallback
            try {
              await navigator.clipboard.writeText(shareText);
              console.log("Share text copied to clipboard");
            } catch (err) {
              console.warn("Clipboard copy failed, continuing with share", err);
            }
            
            // Get the image URL - use cached image if available
            const scoreImageUrl = gameState.cachedShareImage || document.getElementById("shareImage").src;
            
            // Check if running on Android
            const isAndroid = /Android/.test(navigator.userAgent);
            const isWebShareSupported = typeof navigator.share === "function";
            
            if (isWebShareSupported) {
              try {
                // Prepare the image file
                const res = await fetch(scoreImageUrl);
                const blob = await res.blob();
                const file = new File([blob], "finger-circuit-score.png", { type: "image/png" });

                // Prepare share data with text and image
                const shareData = {
                  title: shortTitle,
                  text: shareText,
                  files: [file],
                };

                if (navigator.canShare && navigator.canShare(shareData)) {
                  await navigator.share(shareData);
                  console.log("Shared successfully with image and text via Web Share API");
                  
                  document.getElementById("shareModal").style.display = "none";
                  return;
                }
              } catch (err) {
                if (err.name === "AbortError") {
                  console.log("User cancelled sharing");
                  return;
                }
                console.warn("Share API with files failed, trying next method", err);
              }
            }
            
            // Android-specific LINE deep link fallback (text-only)
            if (isAndroid) {
              try {
                const encodedText = encodeURIComponent(shareText);
                const lineUrl = `line://msg/text/${encodedText}`;
                window.location.href = lineUrl;

                // Check if LINE opened (rudimentary detection)
                setTimeout(() => {
                  if (document.hasFocus()) {
                    console.log("LINE may not be installed or failed to open");
                    downloadImage();
                    document.getElementById("shareModal").style.display = "none";
                  } else {
                    console.log("LINE likely opened");
                    document.getElementById("shareModal").style.display = "none";
                  }
                }, 1500);
                return;
              } catch (err) {
                console.warn("Android LINE deep link failed", err);
              }
            }
            
            // Fallback - download image and show alert
            downloadImage();
            document.getElementById("shareModal").style.display = "none";
          } catch (error) {
            console.error('Share process error:', error);
            document.getElementById("shareModal").style.display = "none";
          }
        }

        // Add download image function
        async function downloadImage() {
          if (!gameState.cachedShareImage) return;
          try {
            const downloadLink = document.createElement("a");
            downloadLink.href = gameState.cachedShareImage;
            downloadLink.download = "finger-circuit-score.png";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
          } catch (downloadError) {
            console.error("Download failed:", downloadError);
          }
        }

        // Show share modal and prepare image
        async function showShareModal() {
          // Update share accuracy value just before showing modal
          document.getElementById("shareAccuracyValue").textContent = gameState.accuracy;
          
          document.getElementById("shareImage").style.display = "none";
          const loadingMsg = document.createElement("p");
          loadingMsg.className = "share-loading";
          loadingMsg.textContent = "生成中...";
          loadingMsg.style.fontFamily = "'JapaneseFont', sans-serif";
          document.querySelector(".share-content").insertBefore(loadingMsg, document.getElementById("universalShareButton"));
          
          // Ensure the share modal doesn't overlap with the header
          const titleBannerHeight = document.querySelector(".title-banner").offsetHeight;
          document.getElementById("shareModal").style.paddingTop = (titleBannerHeight + 5) + "px";
          
          document.getElementById("shareModal").style.display = "flex";
          
          // Prevent scrolling and zooming during share generation
          document.body.style.overflow = "hidden";
          
          // Use a timeout to let the modal appear before generating the image
          setTimeout(async () => {
            try {
              // Use cached image if available, otherwise generate a new one
              if (gameState.cachedShareImage) {
                document.getElementById("shareImage").src = gameState.cachedShareImage;
              } else {
                // Prepare the share element and generate the score card
                await prepareShareElement();
                const imageUrl = await generateScoreCard();
                
                if (imageUrl) {
                  document.getElementById("shareImage").src = imageUrl;
                  gameState.cachedShareImage = imageUrl;
                }
              }
            } catch (error) {
              console.error('Error generating share image:', error);
            } finally {
              // Always restore scrolling
              document.body.style.overflow = "";
            }
            
            // Remove loading message
            if (loadingMsg.parentNode) {
              loadingMsg.parentNode.removeChild(loadingMsg);
            }
            
            // Show the share icon
            const shareButton = document.getElementById("universalShareButton");
            shareButton.innerHTML = `
              <svg class="share-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
                <path d="M0 0h24v24H0z" fill="none"/>
                <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
              </svg>
            `;
            
            // Show the image
            document.getElementById("shareImage").style.display = "block";
          }, 300);
        }

        // Generate the share image with error handling
        async function generateScoreCard() {
          const scoreElement = document.getElementById("scoreElement");
          
          try {
            // Store current scroll position
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            
            // Position the element off-screen but visible to html2canvas
            scoreElement.style.position = 'absolute';
            scoreElement.style.left = '-1000px';
            scoreElement.style.top = '-1000px';
            scoreElement.style.opacity = '1';
            scoreElement.style.zIndex = '-9999';
            
            // Add a small delay to ensure the element is rendered properly
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Convert DOM element to canvas image with better options
            const canvas = await html2canvas(scoreElement, {
              backgroundColor: null,
              scale: 2, // Higher resolution
              logging: false,
              useCORS: true,
              allowTaint: true,
              foreignObjectRendering: false, // More compatible rendering
              scrollX: 0,
              scrollY: 0
            });
            
            // Convert canvas to image URL with maximum quality
            const imageUrl = canvas.toDataURL("image/png", 1.0);
            
            // Set the image source in the share modal
            document.getElementById("shareImage").src = imageUrl;
            
            // Hide the score element again - ensure it's fully hidden
            scoreElement.style.opacity = '0';
            scoreElement.style.left = '-9999px';
            scoreElement.style.top = '-9999px';
            scoreElement.style.zIndex = '-9999';
            
            // Restore scroll position if needed
            if (window.scrollX !== scrollX || window.scrollY !== scrollY) {
              window.scrollTo(scrollX, scrollY);
            }
            
            return imageUrl;
          } catch (error) {
            console.error('Error generating share image:', error);
            
            // Always hide the element in case of error
            scoreElement.style.opacity = '0';
            scoreElement.style.left = '-9999px';
            scoreElement.style.top = '-9999px';
            scoreElement.style.zIndex = '-9999';
            
            // Create a fallback image with just text
            try {
              const fallbackCanvas = document.createElement('canvas');
              fallbackCanvas.width = 320;
              fallbackCanvas.height = 320;
              const ctx = fallbackCanvas.getContext('2d');
              
              // Draw background
              ctx.fillStyle = '#f5f5f5';
              ctx.fillRect(0, 0, 320, 320);
              
              // Draw text
              ctx.fillStyle = '#000000';
              ctx.font = 'bold 24px MyCustomFont, sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText('FINGER CIRCUIT', 160, 100);
              
              ctx.fillStyle = '#fd6aa0';
              ctx.font = 'bold 72px MyCustomFont, sans-serif';
              ctx.fillText(`${gameState.accuracy}%`, 160, 180);
              
              // Return fallback image
              return fallbackCanvas.toDataURL("image/png", 1.0);
            } catch (fallbackError) {
              console.error('Fallback image creation failed:', fallbackError);
              return null;
            }
          }
        }

        function returnToMap() {
          // Add a flag to indicate we're navigating back
          sessionStorage.setItem('returningToMap', 'true');
          
          // Clear any cached images before returning
          if (window.caches && navigator.serviceWorker) {
            // Try to clear image cache if possible
            caches.open('image-cache').then(cache => {
              cache.delete('./assets/car.svg').then(() => {
                console.log('Car image cleared from cache');
              });
            }).catch(err => {
              console.log('Cache clearing not supported');
            });
          }
          
          window.location.href = "https://miniapp.line.me/2007078799-0oWyrXee/circuitjourney";
        }

        function resetGame() {
          // Reset game state
          gameState.status = "initializing";
          gameState.userPath = [];
          gameState.lastPoint = null;
          gameState.lastLiftPoint = null; // Reset last lift point
          gameState.isDrawing = false;
          gameState.circuitCompleted = false;
          gameState.calculatingAccuracy = false;
          gameState.touchedSegments = new Set();
          gameState.allSegmentsTouched = new Set();
          gameState.visitedInOrder = [];
          gameState.justResumedDrawing = false;
          gameState.distanceSinceResume = 0;
          gameState.resumePoint = null;
          gameState.cachedShareImage = null;
          
          // Hide continuation circle
          continuationCircle.style.display = "none";
          
          // Hide result screen
          document.getElementById("resultScreen").style.display = "none";
          
          // Show start elements
          document.getElementById("startPoint").style.opacity = "1";
          document.getElementById("startArrow").style.opacity = "1";
          
          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawCircuit();
          
          // Show intro animation
          const whiteBelt = document.getElementById("whiteBelt");
          const missionBanner = document.querySelector(".mission-banner");
          whiteBelt.style.display = "flex";
          whiteBelt.style.opacity = "1";
          missionBanner.style.display = "block";
          missionBanner.style.opacity = "1";
          
          setTimeout(function () {
            whiteBelt.style.opacity = "0";
            setTimeout(function () {
              whiteBelt.style.display = "none";
              missionBanner.style.opacity = "0";
              setTimeout(function () {
                missionBanner.style.display = "none";
                gameState.status = "ready";
                drawCircuit();
                showStartTooltip();
              }, 500);
            }, 500);
          }, 2000);
        }

        function initGame() {
          try {
            // Initialize canvas and circuit
            resizeCanvas();
            initializeCircuitPath();
            drawCircuit();
            
            // Show intro animation
            const whiteBelt = document.getElementById("whiteBelt");
            const missionBanner = document.querySelector(".mission-banner");
            whiteBelt.style.display = "flex";
            whiteBelt.style.opacity = "1";
            missionBanner.style.opacity = "1";
            gameState.status = "initializing";
            
            // Update game state with better detection settings
            gameState.minCircuitCoverage = 0.0;           // No minimum circuit coverage required
            gameState.completionThreshold = 20;           // More reasonable end point detection radius
            gameState.quickCompletionEnabled = true;      // Enable quick completion
            gameState.checkCompletionOnLift = true;       // Check completion on finger lift
            gameState.minPlayTime = 500;                  // Short minimum play time
            gameState.pathWidth = 25;                     // Slightly wider path width for better detection
            
            setTimeout(function () {
              whiteBelt.style.opacity = "0";
              setTimeout(function () {
                whiteBelt.style.display = "none";
                missionBanner.style.opacity = "0";
                setTimeout(function () {
                  missionBanner.style.display = "none";
                  gameState.status = "ready";
                  drawCircuit();
                  showStartTooltip();
                }, 500);
              }, 500);
            }, 2000);

            // Remove any existing event listeners to prevent duplicates
            canvas.removeEventListener("mousedown", handleStart);
            canvas.removeEventListener("mousemove", handleMove);
            canvas.removeEventListener("mouseup", handleEnd);
            canvas.removeEventListener("touchstart", handleStart);
            canvas.removeEventListener("touchmove", handleMove);
            canvas.removeEventListener("touchend", handleEnd);

            // Add event listeners with passive: false to prevent scrolling
            canvas.addEventListener("mousedown", handleStart, { passive: false });
            canvas.addEventListener("mousemove", handleMove, { passive: false });
            canvas.addEventListener("mouseup", handleEnd, { passive: false });
            canvas.addEventListener("touchstart", handleStart, { passive: false });
            canvas.addEventListener("touchmove", handleMove, { passive: false });
            canvas.addEventListener("touchend", handleEnd, { passive: false });

            // Add button event listeners
            document.getElementById("retryButton").addEventListener("click", resetGame);
            document.getElementById("shareButton").addEventListener("click", showShareModal);
            document.getElementById("mapButton").addEventListener("click", returnToMap);
            
            // Add universal share button event listener
            document.getElementById("universalShareButton").addEventListener("click", shareScore);
            
            // Add close share modal event listener
            document.getElementById("closeShare").addEventListener("click", function() {
              document.getElementById("shareModal").style.display = "none";
            });

            // Add window scroll event listener to update circle position
            window.addEventListener('scroll', function() {
              if (gameState.lastLiftPoint && continuationCircle.style.display === "block") {
                // Adjust for scroll position while maintaining center alignment
                continuationCircle.style.left = (gameState.lastLiftPoint.x - 20 - window.scrollX) + "px";
                continuationCircle.style.top = (gameState.lastLiftPoint.y - 20 - window.scrollY) + "px";
              }
            });
          } catch (error) {
            console.error("Error during game initialization:", error);
          }
        }

        // Start the game
        initGame();
      });
    </script>
  </body>
</html>